# TASK 19 - Hack-a-Gnome
Difficulty: ❄️❄️❄️

## OBJECTIVE : ##
> Davis in the Data Center is fighting a gnome army—join the hack-a-gnome fun.



## HINTS: ##
<details>
  <summary>Hints provided for Task 19</summary>
  
>-  Sometimes, client-side code can interfere with what you submit. Try proxying your requests through a tool like [Burp Suite](https://portswigger.net/burp) or [OWASP ZAP](https://www.zaproxy.org/). You might be able to trigger a revealing error message.

>-	Once you determine the type of database the gnome control factory's login is using, look up its documentation on default document types and properties. This information could help you generate a list of common English first names to try in your attack.

>-  There might be a way to check if an attribute IS_DEFINED on a given entry. This could allow you to brute-force possible attribute names for the target user's entry, which stores their password hash. Depending on the hash type, it might already be cracked and available online where you could find an online cracking station to break it.

>-  I actually helped design the software that controls the factory back when we used it to make toys. It's quite complex. After logging in, there is a front-end that proxies requests to two main components: a backend Statistics page, which uses a per-gnome container to render a template with your gnome's stats, and the UI, which connects to the camera feed and sends control signals to the factory, relaying them to your gnome (assuming the CAN bus controls are hooked up correctly). Be careful, the gnomes shutdown if you logout and also shutdown if they run out of their 2-hour battery life (which means you'd have to start all over again).

>-  Oh no, it sounds like the CAN bus controls are not sending the correct signals! If only there was a way to hack into your gnome's control stats/signal container to get command-line access to the smart-gnome. This would allow you to fix the signals and control the bot to shut down the factory. During my development of the robotic prototype, we found the factory's pollution to be undesirable, which is why we shut it down. If not updated since then, the gnome might be running on old and outdated packages.

>-  Nice! Once you have command-line access to the gnome, you'll need to fix the signals in the canbus_client.py file so they match up correctly. After that, the signals you send through the web UI to the factory should properly control the smart-gnome. You could try sniffing CAN bus traffic, enumerating signals based on any documentation you find, or brute-forcing combinations until you discover the right signals to control the gnome from the web UI.

</details>

#

## PROCEDURE : ##

URI: https://hhc25-smartgnomehack-prod.holidayhackchallenge.com/login?&challenge=termSmartGnome&username=betaj&id=8fd9bfc1-4c4d-446d-bfda-2169f3b46a80&area=gnomefactory&location=6,17&tokens=&dna=ATATATTAATATATATATATATATATATATATCGATTACGATATATATATATTAATATATATATATATTAGCATATCGATATATATATATATTAGCATATATATATATGCGCATATTAGC

If the sheer number of hints for this objective is anything to go by, it's going to be a challenging one!

If we head to the link we're given we are presented with a login screen to access Smart Gnome Control.  There's nothing else to play around with on this screen, apart from a link that says __Register__. This link takes us to a page where we can create a new user and password although we're told that _"Registration is currently closed"_.  There is still somethign that might be useful to us here though...  if we try to enter a username the app checks in realtime to see whetehr the username is taken and lets us know.  So we have a way of querying the database for existing user accounts.

After some playing around with this screen, I found out that typing `"` in the username field triggers an error:

<img width="534" height="521" alt="image" src="https://github.com/user-attachments/assets/34c96d39-208d-446d-ba2a-778340b3479a" />


If we do a quick Google search for this error, we quickly find out that this error is generated by Cosmos DB, so now we can follow the advice of our first hint and read up on default document types and proporties for Cosmos DB.


If we do a quick Google search for this error, we quickly find out that this error is generated by Cosmos DB, so now we can follow the advice of our first hint and read up on default document types and proporties for Cosmos DB.

Using Burp Suite's intruder function, we can see that whenever we try a username a call is made to `userAvailable?username=` with the username we are trying and we get a reply that says `{"available":true}`.

Next I looked for a list of common english names and I downloaded the one found [here](https://github.com/KarlAmort/firstname-database).  I was then able to filter out those names that were English and created a list called [englishnames.txt](/Code/englishnames.txt), which I used together with a [python script](/Code/userenum.py) to try different usernames until I got a reply that said `{"available":false}` which indicates that the username in question exists and is in use.

After waiting for the script to do its thing, I landed on the usernames `bruce` and `harold`.


<img width="349" height="200" alt="image" src="https://github.com/user-attachments/assets/f11ee693-dd51-4478-a3a5-a181b9e1ea00" />


The error we got earlier when inputting a `"` as a username, suggests that the site might be vulverable to some kind of code injection.  Given that the website seems to be using Cosmos DB, we are most likely looking at NoSQLi.  Let's try out some quick tests by entring the following strings in the username field:

  - `bruce` returns _Usernamne is taken_  (i.e. **TRUE**)
  - `bruce" OR 1 --` returns _Usernamne is taken_  (i.e. **TRUE**)
  - `bruce" AND 1 --` returns _Usernamne is available_  (i.e. **FALSE**)
  - `bruce" OR c.username="harold" --` returns _Username is taken_ (i.e. **TRUE**)

Looks like we can try some blind NoSQLi logic tests here.

We can use `IS_DEFINED` to find out if a field exists in the database:  
  - `bruce" AND IS_DEFINED(c.username) --` returns **TRUE**, so we know that the database contains a field called `username` (well we already knew that - but this confirms that we can potentially use NoSQLi to find database field names).
  - `bruce" AND IS_DEFINED(c.id) --` also returns **TRUE**, so we know that the database contains a field called `id`.
  - `bruce" AND IS_DEFINED(c.password) --` returns **FALSE**, so apparently there is no field named `password`.

We can also use `SUBSTRING` to check for specific characters in a known field, for example:
`harold" AND SUBSTRING(c.username,0,1)="h" --` returns **TRUE** because `h` is the first character in the `username` field for user `harold`.

We can use the same technique to determine the value od id for username `harold` or `bruce` with the following input:  `harold" AND SUBSTRING(c.id,0,1)="0" --` and trying different values in the quotes until it returns **TRUE** (i.e. _"Username is Taken"_).  Using this method we can quickly determine that the value of `id` for harold is `1` and for `bruce` it is `2`.

So far it looks like there are only two registered users on the system and the hints lead us to understand that there should be a field containing their password hashes, so we need to try and guess the name of this field.  This part took me a while and I tried all sorts of combinations of `password`, `pwd`, `pw`, `pwdhash`, `pwhash`, etc...  until I finally tried `digest` and sure enough `https://hhc25-smartgnomehack-prod.holidayhackchallenge.com/userAvailable?username=%22%20OR%20IS_DEFINED(c.digest)%20--` returns `{"available":false}` thus confirming that the field exists, and its name indicates that it most likely contains MD5 hashes.

I put together [a python script](Code/digest-extractor.py) that uses the SUBSTRING function to reveal the hash for each user character by character.  This finally gave me the following hashes:

id|username|digest
--|--|--
1|harold|07f456ae6a94cb68d740df548847f459
2|bruce|d0a9ba00f80cbc56584ef245ffc56b9e

I then fed these hashes to [https://crackstation.net/](https://crackstation.net/), which compares the hashes to those of known password/hash pairs.  This revealed the following passwords for the two users:


id|username|digest|password
--|--|--|--
1|harold|07f456ae6a94cb68d740df548847f459|oatmeal!!
2|bruce|d0a9ba00f80cbc56584ef245ffc56b9e|oatmeal12



